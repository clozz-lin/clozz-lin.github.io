(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{581:function(_,v,e){"use strict";e.r(v);var o=e(30),t=Object(o.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("p",[_._v("推荐阅读：")]),_._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://juejin.cn/post/7031775645537566751",target:"_blank",rel:"noopener noreferrer"}},[_._v("Promise基础"),e("OutboundLink")],1)])]),_._v(" "),e("h2",{attrs:{id:"_1-回调地狱"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-回调地狱"}},[_._v("#")]),_._v(" 1.回调地狱")]),_._v(" "),e("p",[e("code",[_._v("多层回调函数的相互嵌套")]),_._v("，就形成了"),e("code",[_._v("回调地狱")]),_._v("。")]),_._v(" "),e("p",[_._v("回调地狱的缺点：")]),_._v(" "),e("ul",[e("li",[_._v("代码耦合性太强，牵一发而动全身，"),e("code",[_._v("难以维护")])]),_._v(" "),e("li",[_._v("大量冗余的代码相互嵌套，代码的"),e("code",[_._v("可读性变差")])])]),_._v(" "),e("p",[_._v("为了解决回调地狱的问题，"),e("code",[_._v("ES6（ECMAScript 2015）")]),_._v("中新增了 "),e("code",[_._v("Promise")]),_._v(" 的概念。")]),_._v(" "),e("h2",{attrs:{id:"_2-promise-的基本概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-promise-的基本概念"}},[_._v("#")]),_._v(" 2.Promise 的基本概念")]),_._v(" "),e("p",[e("strong",[_._v("1."),e("code",[_._v("Promise")]),_._v(" 是一个构造函数")])]),_._v(" "),e("ul",[e("li",[_._v("我们可以创建 "),e("code",[_._v("Promise")]),_._v(" 的实例 "),e("code",[_._v("const p = new Promise()")])]),_._v(" "),e("li",[e("code",[_._v("new")]),_._v(" 出来的 "),e("code",[_._v("Promise")]),_._v(" 实例对象，代表一个异步操作")])]),_._v(" "),e("p",[e("strong",[_._v("2."),e("code",[_._v("Promise.prototype")]),_._v(" 上包含一个 "),e("code",[_._v(".then()")]),_._v(" 方法")])]),_._v(" "),e("ul",[e("li",[_._v("每一次 "),e("code",[_._v("new Promise()")]),_._v(" 构造函数得到的实例对象")]),_._v(" "),e("li",[_._v("都可以通过"),e("code",[_._v("原型链的方式")]),_._v("访问到 "),e("code",[_._v(".then()")]),_._v(" 方法，例如 "),e("code",[_._v("p.then()")])])]),_._v(" "),e("p",[e("strong",[_._v("3."),e("code",[_._v(".then()")]),_._v(" 方法用来预先指定成功和失败的回调函数")])]),_._v(" "),e("ul",[e("li",[_._v("p.then("),e("code",[_._v("成功的回调函数")]),_._v("，"),e("code",[_._v("失败的回调函数")]),_._v(")")]),_._v(" "),e("li",[_._v("p.then("),e("code",[_._v("result")]),_._v(" => { }, "),e("code",[_._v("error")]),_._v(" => { })")]),_._v(" "),e("li",[_._v("调用 .then() 方法时，成功的回调函数是必选的、失败的回调函数是可选的")])]),_._v(" "),e("p",[e("strong",[_._v("4."),e("code",[_._v(".then()")]),_._v(" 方法的特性")])]),_._v(" "),e("p",[_._v("如果上一个 "),e("code",[_._v(".then()")]),_._v(" 方法中返回了一个新的 "),e("code",[_._v("Promise")]),_._v(" 实例对象，则可以通过下一个 "),e("code",[_._v(".then()")]),_._v("继续进行处理。通\n过 "),e("code",[_._v(".then()")]),_._v(" 方法的链式调用，就解决了回调地狱的问题。")]),_._v(" "),e("p",[e("strong",[_._v("5.通过 "),e("code",[_._v(".catch")]),_._v(" 捕获错误")])]),_._v(" "),e("ul",[e("li",[_._v("在 "),e("code",[_._v("Promise")]),_._v(" 的链式操作中如果发生了错误，可以使用 "),e("code",[_._v("Promise.prototype.catch")]),_._v(" 方法进行捕获和处理")]),_._v(" "),e("li",[_._v("如果不希望前面的错误导致后续的 "),e("code",[_._v(".then")]),_._v(" 无法正常执行，则可以将 "),e("code",[_._v(".catch")]),_._v(" 的调用提前")])]),_._v(" "),e("p",[e("strong",[_._v("6. "),e("code",[_._v("Promise.all()")]),_._v(" 方法")])]),_._v(" "),e("p",[e("code",[_._v("Promise.all()")]),_._v(" 方法会发起并行的 "),e("code",[_._v("Promise")]),_._v(" 异步操作，等"),e("code",[_._v("所有的异步操作全部结束后")]),_._v("才会执行下一步的 "),e("code",[_._v(".then")]),_._v("\n操作（等待机制）")]),_._v(" "),e("p",[e("strong",[_._v("7. "),e("code",[_._v("Promise.race()")]),_._v(" 方法")])]),_._v(" "),e("p",[e("code",[_._v("Promise.race()")]),_._v(" 方法会发起并行的 "),e("code",[_._v("Promise")]),_._v(" 异步操作，"),e("code",[_._v("只要任何一个异步操作完成，就立即执行下一步的.then 操作")]),_._v("（赛跑机制）")])])}),[],!1,null,null,null);v.default=t.exports}}]);