---
title: Js
date: 2022-04-24 19:18:06
permalink: /pages/10b382/
comment: false
author: 
  name: cl
  link: https://github.com/clozz-lin
---
## 做了一份前端面试复习计划，保熟～2022年02月06日
下列来源：[做了一份前端面试复习计划，保熟～2022年02月06日](https://juejin.cn/post/7061588533214969892#heading-12)

## 2022三四月前端面试总结

下列来源：[2022三四月前端面试总结](https://juejin.cn/post/7081599008174997517)
+ `变量提升，function声明和var提升的优先级`
+ `说一说defer 和 async`
+ `如何把异步变为同步`
+ `Promise.all的实现`
+ `为什么promise的then方法要返回一个新的promise而不是返回this`
+ `浅拷贝和深拷贝的区别`
+ `手写深拷贝`
+ 



<!-- ## 1、:blush:数据类型
以下是比较重要的几个 js 变量要掌握的点。
### 1.1 基本的数据类型介绍，及值类型和引用类型的理解
在 JS 中共有 8  种基础的数据类型，分别为： `Undefined` 、 `Null` 、 `Boolean` 、 `Number` 、 `String` 、 `Object` 、 `Symbol` 、 `BigInt` 。
其中 `Symbol`  和 `BigInt ` 是 ES6 新增的数据类型，可能会被单独问：

+ `Symbol` 代表独一无二的值，最大的用法是用来定义对象的唯一属性名。
+ `BigInt` 可以表示任意大小的整数。

**值类型的赋值变动过程如下：**
```javascript
let a = 100;
let b = a;
a = 200;
console.log(b); // 100
```
值类型是直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。

**引用类型的赋值变动过程如下：**
```javascript
let a = { age: 20 };
let b = a;
b.age = 30;
console.log(a.age); // 30
```
引用类型存储在*堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能。

### 1.2 数据类型的判断
+ **`typeof`**：能判断所有**值类型**，**函数**。不可对 **null、对象、数组***进行精确判断，因为都返回 `object` 。
```javascript
console.log(typeof undefined); // undefined
console.log(typeof 2); // number
console.log(typeof true); // boolean
console.log(typeof "str"); // string
console.log(typeof Symbol("foo")); // symbol
console.log(typeof 2172141653n); // bigint
console.log(typeof function () {}); // function
// 不能判别
console.log(typeof []); // object
console.log(typeof {}); // object
console.log(typeof null); // object
```
+ **`instanceof`**：能判断**对象**类型，不能判断基本数据类型，其**内部运行机制是判断在其原型链中能否找到该类型的原型**。比如考虑以下代码：
```javascript
class People {}
class Student extends People {}

const vortesnail = new Student();

console.log(vortesnail instanceof People); // true
console.log(vortesnail instanceof Student); // true。
```
其实现就是顺着**原型链**去找，如果能找到对应的 `Xxxxx.prototype`  即为 `true` 。比如这里的 `vortesnail`  作为实例，顺着原型链能找到 `Student.prototype`  及 `People.prototype` ，所以都为 `true` 。

+ **`Object.prototype.toString.call()`**：所有原始数据类型都是能判断的，还有 **Error 对象，Date 对象**等。
 ```javascript
Object.prototype.toString.call(2); // "[object Number]"
Object.prototype.toString.call(""); // "[object String]"
Object.prototype.toString.call(true); // "[object Boolean]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(null); // "[object Null]"
Object.prototype.toString.call(Math); // "[object Math]"
Object.prototype.toString.call({}); // "[object Object]"
Object.prototype.toString.call([]); // "[object Array]"
Object.prototype.toString.call(function () {}); // "[object Function]"
```
在面试中有一个经常被问的问题就是：**如何判断变量是否为数组？**
```javascript
Array.isArray(arr); // true
arr.__proto__ === Array.prototype; // true
arr instanceof Array; // true
Object.prototype.toString.call(arr); // "[object Array]"
```

## 2、 :sleeping:原型和原型链
总结：

+ `原型`：每一个 `JavaScript` 对象（`null` 除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型"继承"属性，其实就是 `prototype` 对象。
+ `原型链`：由相互关联的原型组成的链状结构就是原型链。

先说出总结的话，再举例子说明如何顺着原型链找到某个属性。
## 3、 :heart_eyes:作用域与作用域链
+ `作用域`：规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。换句话说，`作用域决定了代码区块中变量和其他资源的可见性`。（`全局作用域、函数作用域、块级作用域`）
+ `作用域链`：`从当前作用域开始一层层往上找某个变量，如果找到全局作用域还没找到，就放弃寻找 。这种层级关系就是作用域链。`（`由多个执行上下文的变量对象构成的链表就叫做作用域链，学习下面的内容之后再考虑这句话`）

需要注意的是，`js` 采用的是静态作用域，所以函数的作用域在函数定义时就确定了。
## 4、 :stuck_out_tongue_closed_eyes:执行上下文
`总结`：当 `JavaScript` 代码执行一段可执行代码时，会创建对应的执行上下文。对于每个执行上下文，都有三个重要属性：

+ `变量对象`（`Variable object`，`VO`）；
+ `作用域链`（`Scope chain`）；
+ `this`。（关于 `this` 指向问题，在上面推荐的深入系列也有讲从 `ES` 规范讲的，但是实在是难懂，对于应付面试来说以下这篇阮一峰的文章应该就可以了：`JavaScript` 的 `this` 原理）

## 5、 :flushed:闭包
根据 MDN 中文的定义，闭包的定义如下：
> 在 `JavaScript` 中，`每当创建一个函数，闭包就会在函数创建的同时被创建出来。可以在一个内层函数中访问到其外层函数的作用域。`

也可以这样说：
> 闭包是指那些能够访问自由变量的函数。 自由变量是指在函数中使用的，但既不是 **`函数参数`** 也不是`函数的局部变量`的`变量`。 `闭包 = 函数 + 函数能够访问的自由变量`。

**在回答时，我们这样答：**
在某个内部函数的执行上下文创建时，会将父级函数的`活动对象`加到内部函数的` [[scope]]` 中，形成作用域链，所以即使父级函数的执行上下文销毁（即执行上下文栈弹出父级函数的执行上下文），但是因为其`活动对象`还是实际存储在内存中可被内部函数访问到的，从而实现了闭包。

`闭包应用`： 函数作为参数被传递：
```javascript
function print(fn) {
  const a = 200;
  fn();
}

const a = 100;
function fn() {
  console.log(a);
}

print(fn); // 100
```
函数作为返回值被返回：
```javascript
function create() {
  const a = 100;

  return function () {
    console.log(a);
  };
}

const fn = create();
const a = 200;
fn(); // 100
```
**`闭包：自由变量的查找，是在函数定义的地方，向上级作用域查找。不是在执行的地方。`**

`应用实例`：比如缓存工具，隐藏数据，只提供 API 。
```javascript
function createCache() {
  const data = {}; // 闭包中被隐藏的数据，不被外界访问
  return {
    set: function (key, val) {
      data[key] = val;
    },
    get: function (key) {
      return data[key];
    },
  };
}

const c = createCache();
c.set("a", 100);
console.log(c.get("a")); // 100
``` -->
