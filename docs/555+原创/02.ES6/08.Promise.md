---
title: Promise
date: 2022-05-12 19:50:43
permalink: /pages/ce29ea/
author:
  name: cl
  link: https://github.com/clozz-lin
---

## 1.回调地狱

`多层回调函数的相互嵌套`，就形成了`回调地狱`。

回调地狱的缺点：

- 代码耦合性太强，牵一发而动全身，`难以维护`
- 大量冗余的代码相互嵌套，代码的`可读性变差`

为了解决回调地狱的问题，`ES6（ECMAScript 2015）`中新增了 `Promise` 的概念。

## 2.Promise 的基本概念

**1.`Promise` 是一个构造函数**

- 我们可以创建 `Promise` 的实例 `const p = new Promise()`
- `new` 出来的 `Promise` 实例对象，代表一个异步操作

**2.`Promise.prototype` 上包含一个 `.then()` 方法**

- 每一次 `new Promise()` 构造函数得到的实例对象
- 都可以通过`原型链的方式`访问到 `.then()` 方法，例如 `p.then()`

**3.`.then()` 方法用来预先指定成功和失败的回调函数**

- p.then(`成功的回调函数`，`失败的回调函数`)
- p.then(`result` => { }, `error` => { })
- 调用 .then() 方法时，成功的回调函数是必选的、失败的回调函数是可选的

**4.`.then()` 方法的特性**

  如果上一个 `.then()` 方法中返回了一个新的 `Promise` 实例对象，则可以通过下一个 `.then() `继续进行处理。通
  过 `.then()` 方法的链式调用，就解决了回调地狱的问题。

**5.通过 `.catch` 捕获错误**

- 在 `Promise` 的链式操作中如果发生了错误，可以使用 `Promise.prototype.catch` 方法进行捕获和处理
- 如果不希望前面的错误导致后续的 `.then` 无法正常执行，则可以将 `.catch` 的调用提前

**6. `Promise.all()` 方法**

`Promise.all()` 方法会发起并行的 `Promise` 异步操作，等`所有的异步操作全部结束后`才会执行下一步的 `.then `
操作（等待机制）

**7. `Promise.race()` 方法**

`Promise.race()` 方法会发起并行的 `Promise` 异步操作，`只要任何一个异步操作完成，就立即执行下一步的.then 操作`（赛跑机制）
